LEXICAL ANALYZER USING LEX
%{
int COMMENT=0;
%}
identifier [a-zA-Z][a-zA-Z0-9]*
%%
#.* {printf("\n%s is a preprocessor
directive",yytext);}
int |
float |
char |
double |
while |
for |
struct |
typedef |
do |
if |
break |
continue |
void |
switch |
return |
else |
goto {printf(" kwd");}
"/*"
{COMMENT=1;}{printf("comment");}
\+ {if(!COMMENT)printf(" opplus");}
\- {if(!COMMENT)printf(" opsub");}
\* {if(!COMMENT)printf(" opmul");}
\/ {if(!COMMENT)printf(" opdiv");}
{identifier}\({if(!COMMENT)print
f("fun");}
\{ {if(!COMMENT)printf("block
begins");}
\} {if(!COMMENT)printf("block
ends");}
{identifier}(\[[0-9]*\])? {if(!COMMENT) printf("
id");}
\".*\"
{if(!COMMENT)printf("str");}
[0-9]+ {if(!COMMENT)
printf("num");}
\)(\:)?
{if(!COMMENT)printf("\n\t");ECHO
;printf("\n");}
\( ECHO;
= {if(!COMMENT)printf(" opequ");}
\<= |
\>= |
\< |
\> {if(!COMMENT) printf("relop");}
%%
int main(int argc, char **argv)
{
FILE *file;
file=fopen("input.c","r");
if(!file)
{
printf("could not open the
file");
exit(0);
}
yyin=file;
yylex();
printf("\n");
return(0);
}
int yywrap()
{
return(1);
}

//***************************************
COUNT NO. OF WORDS
%{
#include<stdio.h>
#include<string.h>
int i = 0;
%}
%%
([a-zA-Z0-9])* {i++;}
"\n" {printf("%d\n", i); i = 0;}
%%
int yywrap(void){}
int main()
{
yylex();
return 0;
}
COUNTING VOWELS AND CONSONANTS
%{
int vow_count=0;
int const_count =0;
%}
%%
[aeiouAEIOU] {vow_count++;}
[a-zA-Z] {const_count++;}
%%
int yywrap(){}
int main()
{
printf("Enter the string of
vowels and consonants:");
yylex();
printf("Number of vowels are:
%d\n", vow_count);
printf("Number of consonants
are: %d\n", const_count);
return 0;
}

//***************************************
VALID ARITHMETIC
EXPRESSION(yacc)
Valid.l
%{
#include "y.tab.h"
%}
%%
[a-zA-Z_][a-zA-Z_0-9]* return
id;
[0-9]+(\.[0-9]*)? return num;
[+/*] return op;
. return yytext[0];
\n return 0;
%%
int yywrap()
{
return 1;
}
Valid.y
%{
#include<stdio.h>
int flag=0;
%}
%token NUMBER
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'
%%
ArithmeticExpression: E{
// printf("\nResult=%d\n",$$);
return 0;
};
E:E'+'E {$$=$1+$3;}
|E'-'E {$$=$1-$3;}
|E''E {$$=$1$3;}
|E'/'E {$$=$1/$3;}
|E'%'E {$$=$1%$3;}
|'('E')' {$$=$2;}
| NUMBER {$$=$1;}
;
%%
void main()
{
printf("\nEnter Any Arithmetic
Expression:\n");
yyparse();
if(flag==0)
{ printf("Valid
Expression\n\n");}
}
void yyerror()
{
printf("\nInvalid\n\n");
flag=1;
}

//***************************************
VALID IDENTIFIER(yacc)
Lex Part
%{
#include "y.tab.h"
%}
%%
[a-zA-Z_][a-zA-Z_0-9]* return
letter;
[0-9] return digit;
. return yytext[0];
\n return 0;
%%
int yywrap()
{
return 1;
}
Yacc Part
%{
#include<stdio.h>
int valid=1;
%}
%token digit letter
%%
start : letter s
s : letter s
| digit s
|
;
%%
int yyerror()
{
printf("\nIts not a
identifier!\n");
valid=0;
return 0;
}
int main()
{
printf("\nEnter a name to
tested for identifier ");
yyparse();
if(valid)
{
printf("\nIt is a
identifier!\n");
}
}

//*******************************
CONVERT SUBSTRING abc-ABC
%{
#include
#include
int i;
%}
%%
[a-z A-Z]* {
for(i=0;i<=yyleng;i++)
{
if((yytext[i]=='a')&&(yytext[i
+1]=='b')&&(yytext[i+2]=='c'))
{
yytext[i]='A';
yytext[i+1]='B';
yytext[i+2]='C';
}}
printf("%s",yytext);
}
[\t]* return;
.* {ECHO;}
\n {printf("%s",yytext);}
%%
main()
{
yylex();
}
int yywrap()
{
return 1;
}

//**********************************
CALCULATOR
Lex Part
%{
#include<stdio.h>
#include "y.tab.h"
extern int yylval;
%}
%%
[0-9]+ {
yylval=atoi(yytext);
return NUMBER;
}
[\t] ;
[\n] return 0;
. return yytext[0];
%%
int yywrap()
{
return 1;
}
Yacc Part
%{
#include<stdio.h>
int flag=0;
%}
%token NUMBER
%left '+' '-'
%left '*' '/' '%'
%left '(' ')'
%%
ArithmeticExpression: E{
printf("\nResult=%d\n",$$);
return 0;
};
E:E'+'E {$$=$1+$3;}
|E'-'E {$$=$1-$3;}
|E'*'E {$$=$1*$3;}
|E'/'E {$$=$1/$3;}
|E'%'E {$$=$1%$3;}
|'('E')' {$$=$2;}
| NUMBER {$$=$1;}
;
%%
void main()
{
printf("\nEnter Any Arithmetic
Expression:\n");
yyparse();
if(flag==0)
printf("\n\n");
}
void yyerror()
{
printf("\nInvalid\n\n");
flag=1;
}

//********************************************

OUTPUT: CONVERT SUBSTRING abc-ABC
[CSE@localhost ~]$ lex lexl.l
[CSE@localhost ~]$ cc lex.yy.c  or gcc lex.yy.c -lfl
[CSE@localhost ~]$ ./a.out
hiabc
hiABC

//*******************************************
VALID IDENTIFIER
yacc -d 4b. y
lex 4b.l
gcc lex.yy.c y.tab.c -w
./a.out
